1. Создаём свой чекер AuthCheckerBearer:
    1. Наследуемся от AuthCheckerBase.
    2. Перегружаем CheckAuth (парсим и валидируем request, записываем информацию о юзере в request_context) и SupportsUserAuth (true).
    3. Добавляем поля AuthCache (ищем в нём спаршенный token) и vector<\UserScope> (тут хранятся необходимые для доступа spoce. Проверяем их наличие из спаршенного request).
2. Создаём CheckerFactory:
    1. Наследуемся от AuthCheckerFactoryBase.
    2. Перегружаем operator(). В операторе конструируем наш чекер через shared_ptr.
3. Регистрируем CheckerFactory в main().

- Можно регистрировать по одной CheckerFactory на каждый тип аутентификации (basic, bearer, digest, etc.). Если factory для данного типа уже существует, кидается исключение.
- Factory конструирует чекер на каждую HTTP ручку с соответствующим типом аутентификации.

Flow BearerAuth:
1. При запуске сервиса userver тянет кеш из БД в AuthCache, а factory для каждой ручки конструирует чекеры. В случае BearerAuth, Factory забирает список scope'ов из static_config, указатель на AuthCache и сохраняет их в поля BearerChecker.  
2. Когда в ручку Hello приходит запрос, то сначала он попадает в функцию CheckAuth соответствующего чекера. В этой функции написана основная логика:
    1. Парсинг.
    2. Проверка на наличие хедера Authorization, на соответствие типа аутентификации, на наличие токена, на наличие всех scopes.
    3. Делается снапшот кеша, в котором ищется юзер с пришедшим токеном.
    4. Если токен найден, в RequestContext записывается информация о юзере.
    5. Если появилась проблема, она возвращается в структуре AuthCheckerResult.